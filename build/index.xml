<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Overview of Docker Build on Docker Docs</title>
    <link>https://docker.qubitpi.org/build/</link>
    <description>Recent content in Overview of Docker Build on Docker Docs</description>
    <generator>Hugo</generator>
    <language>en</language>
    <atom:link href="https://docker.qubitpi.org/build/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Annotations</title>
      <link>https://docker.qubitpi.org/build/building/annotations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/annotations/</guid>
      <description>Annotations provide descriptive metadata for images. Use annotations to record arbitrary information and attach it to your image, which helps consumers and tools understand the origin, contents, and how to use the image.&#xA;Annotations are similar to, and in some sense overlap with, labels. Both serve the same purpose: attach metadata to a resource. As a general principle, you can think of the difference between annotations and labels as follows:</description>
    </item>
    <item>
      <title>Base images</title>
      <link>https://docker.qubitpi.org/build/building/base-images/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/base-images/</guid>
      <description>All Dockerfiles start from a base image. A base is the image that your image extends. It refers to the contents of the FROM instruction in the Dockerfile.&#xA;FROM debian For most cases, you don&#39;t need to create your own base image. Docker Hub contains a vast library of Docker images that are suitable for use as a base image in your build. Docker Official Images are specifically designed as a set of hardened, battle-tested images that support a wide variety of platforms, languages, and frameworks.</description>
    </item>
    <item>
      <title>Build context</title>
      <link>https://docker.qubitpi.org/build/building/context/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/context/</guid>
      <description>The docker build and docker buildx build commands build Docker images from a Dockerfile and a context.&#xA;What is a build context? The build context is the set of files that your build can access. The positional argument that you pass to the build command specifies the context that you want to use for the build:&#xA;$ docker build [OPTIONS] PATH | URL | - ^^^^^^^^^^^^^^ You can pass any of the following inputs as the context for a build:</description>
    </item>
    <item>
      <title>Build release notes</title>
      <link>https://docker.qubitpi.org/build/release-notes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/release-notes/</guid>
      <description>This page contains information about the new features, improvements, and bug fixes in Docker Buildx.&#xA;0.14.0 2024-04-18 The full release note for this release is available on GitHub.&#xA;Enhancements Add support for --print=lint (experimental). docker/buildx#2404, docker/buildx#2406 Fix JSON formatting for custom implementations of print sub-requests in frontends. docker/buildx#2374 Provenance records are now set when building with --metadata-file. docker/buildx#2280 Add Git authentication support for remote definitions. docker/buildx#2363 New default-load driver option for the docker-container, remote, and kubernetes drivers to load build results to the Docker Engine image store by default.</description>
    </item>
    <item>
      <title>Build secrets</title>
      <link>https://docker.qubitpi.org/build/building/secrets/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/secrets/</guid>
      <description>A build secret is any piece of sensitive information, such as a password or API token, consumed as part of your application&#39;s build process.&#xA;Build arguments and environment variables are inappropriate for passing secrets to your build, because they persist in the final image. Instead, you should use secret mounts or SSH mounts, which expose secrets to your builds securely.&#xA;Secret mounts Secret mounts expose secrets to the build containers as files.</description>
    </item>
    <item>
      <title>Build variables</title>
      <link>https://docker.qubitpi.org/build/building/variables/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/variables/</guid>
      <description>In Docker Build, build arguments (ARG) and environment variables (ENV) both serve as a means to pass information into the build process. You can use them to parameterize the build, allowing for more flexible and configurable builds.&#xA;Warning&#xA;Build arguments and environment variables are inappropriate for passing secrets to your build, because they&#39;re exposed in the final image. Instead, use secret mounts or SSH mounts, which expose secrets to your builds securely.</description>
    </item>
    <item>
      <title>Building best practices</title>
      <link>https://docker.qubitpi.org/build/building/best-practices/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/best-practices/</guid>
      <description>Use multi-stage builds Multi-stage builds let you reduce the size of your final image, by creating a cleaner separation between the building of your image and the final output. Split your Dockerfile instructions into distinct stages to make sure that the resulting output only contains the files that&#39;s needed to run the application.&#xA;Using multiple stages can also let you build more efficiently by executing build steps in parallel.</description>
    </item>
    <item>
      <title>Checking your build configuration</title>
      <link>https://docker.qubitpi.org/build/checks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/checks/</guid>
      <description>Introduced in Buildx version 0.15.0 Build checks are a feature introduced in Dockerfile 1.8. It lets you validate your build configuration and conduct a series of checks prior to executing your build. Think of it as an advanced form of linting for your Dockerfile and build options, or a dry-run mode for builds.&#xA;You can find the list of checks available, and a description of each, in the Build checks reference.</description>
    </item>
    <item>
      <title>Custom Dockerfile syntax</title>
      <link>https://docker.qubitpi.org/build/dockerfile/frontend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/dockerfile/frontend/</guid>
      <description>Dockerfile frontend BuildKit supports loading frontends dynamically from container images. To use an external Dockerfile frontend, the first line of your Dockerfile needs to set the syntax directive pointing to the specific image you want to use:&#xA;# syntax=[remote image reference] For example:&#xA;# syntax=docker/dockerfile:1 # syntax=docker.io/docker/dockerfile:1 # syntax=example.com/user/repo:tag@sha256:abcdef... You can also use the predefined BUILDKIT_SYNTAX build argument to set the frontend image reference on the command line:&#xA;$ docker build --build-arg BUILDKIT_SYNTAX=docker/dockerfile:1 .</description>
    </item>
    <item>
      <title>Docker Build architecture</title>
      <link>https://docker.qubitpi.org/build/architecture/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/architecture/</guid>
      <description>Docker Build implements a client-server architecture, where:&#xA;Buildx is the client and the user interface for running and managing builds BuildKit is the server, or builder, that handles the build execution. As of Docker Engine 23.0 and Docker Desktop 4.19, Buildx is the default build client.&#xA;Buildx Buildx is a CLI tool that provides a user interface for working with builds. Buildx is a drop-in replacement for the legacy build client used in earlier versions of Docker Engine and Docker Desktop.</description>
    </item>
    <item>
      <title>Dockerfile release notes</title>
      <link>https://docker.qubitpi.org/build/dockerfile/release-notes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/dockerfile/release-notes/</guid>
      <description>This page contains information about the new features, improvements, known issues, and bug fixes in Dockerfile reference.&#xA;For usage, see the Dockerfile frontend syntax page.&#xA;1.7.0 2024-03-06 Stable # syntax=docker/dockerfile:1.7 Variable expansion now allows string substitutions and trimming. moby/buildkit#4427, moby/buildkit#4287 Named contexts with local sources now correctly transfer only the files used in the Dockerfile instead of the full source directory. moby/buildkit#4161 Dockerfile now better validates the order of stages and returns nice errors with stack traces if stages are in incorrect order.</description>
    </item>
    <item>
      <title>Multi-platform images</title>
      <link>https://docker.qubitpi.org/build/building/multi-platform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/multi-platform/</guid>
      <description>A multi-platform image refers to a single image that includes variants for multiple different architectures and, in some cases, different operating systems, like Windows. This means that whether you are using an ARM-based system or an x86 machine, Docker automatically detects and selects the appropriate variant for your hosts&#39;s operating system and architecture.&#xA;Many of the Docker Official Images available on Docker Hub support various architectures. For instance, the busybox image includes support for these platforms:</description>
    </item>
    <item>
      <title>Multi-stage builds</title>
      <link>https://docker.qubitpi.org/build/building/multi-stage/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/multi-stage/</guid>
      <description>Multi-stage builds are useful to anyone who has struggled to optimize Dockerfiles while keeping them easy to read and maintain.&#xA;Use multi-stage builds With multi-stage builds, you use multiple FROM statements in your Dockerfile. Each FROM instruction can use a different base, and each of them begins a new stage of the build. You can selectively copy artifacts from one stage to another, leaving behind everything you don&#39;t want in the final image.</description>
    </item>
    <item>
      <title>OpenTelemetry support</title>
      <link>https://docker.qubitpi.org/build/building/opentelemetry/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/opentelemetry/</guid>
      <description>Both Buildx and BuildKit support OpenTelemetry.&#xA;To capture the trace to Jaeger, set JAEGER_TRACE environment variable to the collection address using a driver-opt.&#xA;First create a Jaeger container:&#xA;$ docker run -d --name jaeger -p &amp;#34;6831:6831/udp&amp;#34; -p &amp;#34;16686:16686&amp;#34; --restart unless-stopped jaegertracing/all-in-one Then create a docker-container builder that will use the Jaeger instance via the JAEGER_TRACE env var:&#xA;$ docker buildx create --use \ --name mybuilder \ --driver docker-container \ --driver-opt &amp;#34;network=host&amp;#34; \ --driver-opt &amp;#34;env.</description>
    </item>
    <item>
      <title>Packaging your software</title>
      <link>https://docker.qubitpi.org/build/building/packaging/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://docker.qubitpi.org/build/building/packaging/</guid>
      <description>Dockerfile It all starts with a Dockerfile.&#xA;Docker builds images by reading the instructions from a Dockerfile. A Dockerfile is a text file containing instructions for building your source code. The Dockerfile instruction syntax is defined by the specification reference in the Dockerfile reference.&#xA;Here are the most common types of instructions:&#xA;Instruction Description FROM &amp;lt;image&amp;gt; Defines a base for your image. RUN &amp;lt;command&amp;gt; Executes any commands in a new layer on top of the current image and commits the result.</description>
    </item>
  </channel>
</rss>
